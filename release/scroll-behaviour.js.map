{"version":3,"file":"scroll-behaviour.js","sources":["scroll-behaviour.ts"],"sourcesContent":["//<editor-fold desc=\"static scroll utils\">\r\n\r\nimport { DragImageTranslateOverrideFn } from \"./index\";\r\nimport { Point } from \"./internal/dom-utils\";\r\n\r\ninterface ScrollIntentions {\r\n    horizontal:ScrollIntention;\r\n    vertical:ScrollIntention;\r\n}\r\n\r\ninterface IScrollBounds {\r\n    x:number;\r\n    y:number;\r\n    width:number;\r\n    height:number;\r\n    scrollX:number;\r\n    scrollY:number;\r\n    scrollHeight:number;\r\n    scrollWidth:number;\r\n}\r\n\r\nconst enum ScrollIntention {\r\n    NONE = 0,\r\n    LEFT_OR_TOP = -1,\r\n    RIGHT_OR_BOTTOM = 1\r\n}\r\n\r\nconst enum ScrollAxis {\r\n    HORIZONTAL,\r\n    VERTICAL\r\n}\r\n\r\nfunction isTopLevelEl( el:HTMLElement ):boolean {\r\n\r\n    return (el === document.body || el === document.documentElement);\r\n}\r\n\r\nfunction getElementViewportOffset( el:HTMLElement, axis:ScrollAxis ) {\r\n    let offset:number;\r\n\r\n    if( isTopLevelEl( el ) ) {\r\n        offset = (axis === ScrollAxis.HORIZONTAL) ? el.clientLeft : el.clientTop;\r\n    }\r\n    else {\r\n        const bounds = el.getBoundingClientRect();\r\n        offset = (axis === ScrollAxis.HORIZONTAL) ? bounds.left : bounds.top;\r\n    }\r\n\r\n    return offset;\r\n}\r\n\r\nfunction getElementViewportSize( el:HTMLElement, axis:ScrollAxis ) {\r\n    let size:number;\r\n\r\n    if( isTopLevelEl( el ) ) {\r\n        size = (axis === ScrollAxis.HORIZONTAL) ? window.innerWidth : window.innerHeight;\r\n    }\r\n    else {\r\n        size = (axis === ScrollAxis.HORIZONTAL) ? el.clientWidth : el.clientHeight;\r\n    }\r\n\r\n    return size;\r\n}\r\n\r\nfunction getSetElementScroll( el:HTMLElement, axis:ScrollAxis, scroll?:number ) {\r\n    const prop = (axis === ScrollAxis.HORIZONTAL) ? \"scrollLeft\" : \"scrollTop\";\r\n\r\n    // abstracting away compatibility issues on scroll properties of document/body\r\n    const isTopLevel = isTopLevelEl( el );\r\n\r\n    if( arguments.length === 2 ) {\r\n\r\n        if( isTopLevel ) {\r\n            return document.body[ prop ] || document.documentElement[ prop ];\r\n        }\r\n\r\n        return el[ prop ];\r\n    }\r\n\r\n    if( isTopLevel ) {\r\n        document.documentElement[ prop ] += scroll;\r\n        document.body[ prop ] += scroll;\r\n    }\r\n    else {\r\n        el[ prop ] += scroll;\r\n    }\r\n}\r\n\r\n//TODO check if scroll end is reached according to scroll intention? this is needed to implement scroll chaining\r\nfunction isScrollable( el:HTMLElement ):boolean {\r\n    const cs = getComputedStyle( el );\r\n\r\n    if( el.scrollHeight > el.clientHeight && (cs.overflowY === \"scroll\" || cs.overflowY === \"auto\") ) {\r\n        return true;\r\n    }\r\n\r\n    if( el.scrollWidth > el.clientWidth && (cs.overflowX === \"scroll\" || cs.overflowX === \"auto\") ) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction findScrollableParent( el:HTMLElement ):HTMLElement {\r\n    do {\r\n        if( !el ) {\r\n            return undefined;\r\n        }\r\n        if( isScrollable( el ) ) {\r\n            return el;\r\n        }\r\n        if( el === document.documentElement ) {\r\n            return null;\r\n        }\r\n    } while( el = <HTMLElement>el.parentNode );\r\n    return null;\r\n}\r\n\r\nfunction determineScrollIntention( currentCoordinate:number, size:number, threshold:number ):ScrollIntention {\r\n\r\n    // LEFT / TOP\r\n    if( currentCoordinate < threshold ) {\r\n        return ScrollIntention.LEFT_OR_TOP;\r\n    }\r\n    // RIGHT / BOTTOM\r\n    else if( size - currentCoordinate < threshold ) {\r\n        return ScrollIntention.RIGHT_OR_BOTTOM;\r\n    }\r\n    // NONE\r\n    return ScrollIntention.NONE;\r\n}\r\n\r\nfunction determineDynamicVelocity( scrollIntention:ScrollIntention, currentCoordinate:number, size:number, threshold:number ):number {\r\n\r\n    if( scrollIntention === ScrollIntention.LEFT_OR_TOP ) {\r\n\r\n        return Math.abs( currentCoordinate - threshold );\r\n    }\r\n    else if( scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM ) {\r\n\r\n        return Math.abs( size - currentCoordinate - threshold );\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nfunction isScrollEndReached( axis:ScrollAxis, scrollIntention:ScrollIntention, scrollBounds:IScrollBounds ) {\r\n\r\n    const currentScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? (scrollBounds.scrollX) : (scrollBounds.scrollY);\r\n\r\n    // wants to scroll to the right/bottom\r\n    if( scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM ) {\r\n\r\n        const maxScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? (scrollBounds.scrollWidth - scrollBounds.width) : (scrollBounds.scrollHeight -\r\n            scrollBounds.height);\r\n\r\n        // is already at the right/bottom edge\r\n        return currentScrollOffset >= maxScrollOffset;\r\n    }\r\n    // wants to scroll to the left/top\r\n    else if( scrollIntention === ScrollIntention.LEFT_OR_TOP ) {\r\n\r\n        // is already at left/top edge\r\n        return (currentScrollOffset <= 0);\r\n    }\r\n    // no scroll\r\n    return true;\r\n}\r\n\r\n//</editor-fold>\r\n\r\nlet _options:ScrollOptions = {\r\n    threshold: 75,\r\n    // simplified cubic-ease-in function\r\n    velocityFn: function( velocity:number, threshold:number ) {\r\n        const multiplier = velocity / threshold;\r\n        const easeInCubic = multiplier * multiplier * multiplier;\r\n        return easeInCubic * threshold;\r\n    }\r\n};\r\n\r\nlet _scrollIntentions:ScrollIntentions = {\r\n    horizontal: ScrollIntention.NONE,\r\n    vertical: ScrollIntention.NONE\r\n};\r\n\r\nlet _dynamicVelocity:Point = {\r\n    x: 0,\r\n    y: 0\r\n};\r\n\r\nlet _scrollAnimationFrameId:any;\r\nlet _currentCoordinates:Point;\r\nlet _hoveredElement:HTMLElement;\r\nlet _scrollableParent:HTMLElement;\r\nlet _translateDragImageFn:( offsetX:number, offsetY:number ) => void;\r\n\r\n/**\r\n * core handler function\r\n */\r\nfunction handleDragImageTranslateOverride( event:TouchEvent,\r\n                                           currentCoordinates:Point,\r\n                                           hoveredElement:HTMLElement,\r\n                                           translateDragImageFn:( scrollDiffX:number, scrollDiffY:number ) => void ):void {\r\n\r\n    _currentCoordinates = currentCoordinates;\r\n    _translateDragImageFn = translateDragImageFn;\r\n\r\n    // update parent if hovered element changed\r\n    if( _hoveredElement !== hoveredElement ) {\r\n\r\n        _hoveredElement = hoveredElement;\r\n        _scrollableParent = findScrollableParent( _hoveredElement );\r\n    }\r\n\r\n    // update scroll intention and check if we should scroll at all\r\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\r\n    const performScrollAnimation = updateScrollIntentions( _currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity );\r\n\r\n    // no animation in progress but scroll is intended\r\n    if( performScrollAnimation ) {\r\n\r\n        // setup scroll animation frame\r\n        scheduleScrollAnimation();\r\n    }\r\n    else if( !!_scrollAnimationFrameId ) {\r\n\r\n        window.cancelAnimationFrame( _scrollAnimationFrameId );\r\n        _scrollAnimationFrameId = null;\r\n    }\r\n}\r\n\r\n//<editor-fold desc=\"programmatic scroll animation frame handler\">\r\n\r\nfunction scheduleScrollAnimation() {\r\n\r\n    // prevent scheduling when already scheduled\r\n    if( !!_scrollAnimationFrameId ) {\r\n\r\n        return;\r\n    }\r\n\r\n    _scrollAnimationFrameId = window.requestAnimationFrame( scrollAnimation );\r\n}\r\n\r\nfunction scrollAnimation() {\r\n\r\n    let scrollDiffX = 0,\r\n        scrollDiffY = 0,\r\n        isTopLevel = isTopLevelEl( _scrollableParent );\r\n\r\n    if( _scrollIntentions.horizontal !== ScrollIntention.NONE ) {\r\n\r\n        scrollDiffX = Math.round( _options.velocityFn( _dynamicVelocity.x, _options.threshold ) * _scrollIntentions.horizontal );\r\n        getSetElementScroll( _scrollableParent, ScrollAxis.HORIZONTAL, scrollDiffX );\r\n    }\r\n\r\n    if( _scrollIntentions.vertical !== ScrollIntention.NONE ) {\r\n\r\n        scrollDiffY = Math.round( _options.velocityFn( _dynamicVelocity.y, _options.threshold ) * _scrollIntentions.vertical );\r\n        getSetElementScroll( _scrollableParent, ScrollAxis.VERTICAL, scrollDiffY );\r\n    }\r\n\r\n    if( isTopLevel ) {\r\n        // on top level element scrolling we need to translate the drag image as much as we scroll\r\n        _translateDragImageFn( scrollDiffX, scrollDiffY );\r\n    }\r\n    else {\r\n        // just scroll the container and update the drag image position without offset\r\n        _translateDragImageFn( 0, 0 );\r\n    }\r\n\r\n    // reset to make sure we can re-schedule scroll animation\r\n    _scrollAnimationFrameId = null;\r\n\r\n    // check if we should continue scrolling\r\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\r\n    if( updateScrollIntentions( _currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity ) ) {\r\n\r\n        // re-schedule animation frame callback\r\n        scheduleScrollAnimation();\r\n    }\r\n}\r\n\r\n//</editor-fold>\r\n\r\n//<editor-fold desc=\"scroll checks\">\r\n\r\nfunction updateScrollIntentions( currentCoordinates:Point,\r\n                                 scrollableParent:HTMLElement,\r\n                                 threshold:number,\r\n                                 scrollIntentions:ScrollIntentions,\r\n                                 dynamicVelocity:Point ):boolean {\r\n\r\n    if( !currentCoordinates || !scrollableParent ) {\r\n\r\n        // when coordinates become undefined drag operation stopped. stop scrolling also.\r\n        return false;\r\n    }\r\n\r\n    const scrollableParentBounds:IScrollBounds = {\r\n        x: getElementViewportOffset( scrollableParent, ScrollAxis.HORIZONTAL ),\r\n        y: getElementViewportOffset( scrollableParent, ScrollAxis.VERTICAL ),\r\n        width: getElementViewportSize( scrollableParent, ScrollAxis.HORIZONTAL ),\r\n        height: getElementViewportSize( scrollableParent, ScrollAxis.VERTICAL ),\r\n        scrollX: getSetElementScroll( scrollableParent, ScrollAxis.HORIZONTAL ),\r\n        scrollY: getSetElementScroll( scrollableParent, ScrollAxis.VERTICAL ),\r\n        scrollWidth: scrollableParent.scrollWidth,\r\n        scrollHeight: scrollableParent.scrollHeight\r\n    };\r\n\r\n    const currentCoordinatesOffset = {\r\n        x: currentCoordinates.x - scrollableParentBounds.x,\r\n        y: currentCoordinates.y - scrollableParentBounds.y\r\n    };\r\n\r\n    scrollIntentions.horizontal = determineScrollIntention( currentCoordinatesOffset.x, scrollableParentBounds.width, threshold );\r\n    scrollIntentions.vertical = determineScrollIntention( currentCoordinatesOffset.y, scrollableParentBounds.height, threshold );\r\n\r\n    if( scrollIntentions.horizontal && isScrollEndReached( ScrollAxis.HORIZONTAL, scrollIntentions.horizontal, scrollableParentBounds ) ) {\r\n\r\n        // if scroll end is reached, reset to none\r\n        scrollIntentions.horizontal = ScrollIntention.NONE;\r\n    }\r\n    else if( scrollIntentions.horizontal ) {\r\n\r\n        dynamicVelocity.x = determineDynamicVelocity( scrollIntentions.horizontal, currentCoordinatesOffset.x, scrollableParentBounds.width, threshold );\r\n    }\r\n\r\n    if( scrollIntentions.vertical && isScrollEndReached( ScrollAxis.VERTICAL, scrollIntentions.vertical, scrollableParentBounds ) ) {\r\n\r\n        // if scroll end is reached, reset to none\r\n        scrollIntentions.vertical = ScrollIntention.NONE;\r\n    }\r\n    else if( scrollIntentions.vertical ) {\r\n\r\n        dynamicVelocity.y = determineDynamicVelocity( scrollIntentions.vertical, currentCoordinatesOffset.y, scrollableParentBounds.height, threshold );\r\n    }\r\n\r\n    return !!(scrollIntentions.horizontal || scrollIntentions.vertical);\r\n}\r\n\r\n//</editor-fold>\r\n\r\n//<editor-fold desc=\"public api\">\r\n\r\nexport interface ScrollOptions {\r\n    // threshold in px. when distance between scrollable element edge and touch position is smaller start programmatic scroll.\r\n    // defaults to 75px\r\n    threshold?:number;\r\n    // function to customize the scroll velocity\r\n    // velocity param: distance to scrollable element edge\r\n    // threshold: the threshold used to determine when scrolling should start\r\n    // defaults to cubic-ease-in.\r\n    velocityFn:( velocity:number, threshold:number ) => number;\r\n}\r\n\r\nexport const scrollBehaviourDragImageTranslateOverride:DragImageTranslateOverrideFn = handleDragImageTranslateOverride;\r\n\r\n//</editor-fold>\r\n"],"names":[],"mappings":"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"}